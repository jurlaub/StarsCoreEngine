"""
    This file is part of Stars Core Engine, which provides an interface and processing of Stars data.
    Copyright (C) 2014  <Joshua Urlaub + Contributors>

    Stars Core Engine is free software: you can redistribute it and/or modify
    it under the terms of the Lesser GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Stars Core Engine is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    Lesser GNU General Public License for more details.

    You should have received a copy of the Lesser GNU General Public License
    along with Stars Core Engine.  If not, see <http://www.gnu.org/licenses/>.

    Contributors to this project agree to abide by the interpretation expressed in the 
    COPYING.Interpretation document.

"""
from .planet import Colony, Planet
from .research import set_base_tech

'''
    Player Data

    players race file starts as <'race_name'.r1>
    > this establishes the basic race information that is generated by the RaceWizard
    RaceWizard data needs to be saved and referenced. 

    PRT Summary:
    >PRT ==> changes how species operate in some manner. typically acts as an augmentation
    >>> WM = extra hulls + tech, better invasion, better ship speed etc, invasion benefit
    >>> SS = base stealth, extra hulls, extra tech, capture percent of research resources
    >>> JOAT = base pop higher, scout hulls have intrinsic pen scanners
    >>> IT = extra tech, jump cargo and pop through gates, better at gating, 2nd planets
    >>> PP = extra tech, extra planet, diff pack behavior
    >>> SD = extra hulls, extra tech, diff minefild behavior,
    >>> HE = extra hulls, extra engine, double growthrate, half pop capacity
    >>> IS = extra tech, invasion benefit
    >>> AR = special housing, extra hulls, different behavior


    >LRT ==> chages how a species operate in a smaller manner
    >>> UR = ultimate recycling
    >>> IFE = Access two unique engines? no ramscoops
    >>> Double Shields = 
    >>> no pen scanners
    >>> 



    > Player object should track
    >> race file data
    >> habitable planets (list?)
    >> (list?) of fleets object ids 
    >> minefild list?
    >> tech levels
    >> ship designs
    >> player VC data
    >>

'''

'''
    New Game  & New player
    > player race file name is added to the Custom File.
    > one name for each list.
    > name of file must match race name for new game setup

'''


class Player(object):
    """
    Contains player related data that is not space objects.

    Case for multiple inheritance:
    > inherits a set of behaviors that changes based on the PRT



    """

    def __init__(self, raceData):
        self.raceName = raceData.raceName
        self.raceNamePlural = raceData.raceName

        self.PRT = raceData.PRT     # apply PRT values after player variables set,
        self.LRT = raceData.LRT   # apply LRT values after player is updated with PRT variables
        

        self.raceData = raceData        # 


        self.growthRate = raceData.growthRate
        self.popEfficiency = raceData.popEfficiency

        self.habGravityCenter = raceData.habGravityCenter  # (centerpoint, Click width)?  
        self.habGravRange = raceData.habGravRange  # pos range from Center. Total range doubled  
        
        self.habTempCenter = raceData.habTempCenter
        self.habTempRange = raceData.habTempRange

        self.habRadCenter = raceData.habRadCenter
        self.habRadRange = raceData.habRadRange

        self.factoryProduce = raceData.factoryProduce   # 10 factories produce n resources a year
        self.factoryOperate = raceData.factoryOperate   # 10,000 colonist operate n factories       
        self.mineProduce = raceData.mineProduce     # 10 mines produce n kt of each mineral a year
        self.mineOperate = raceData.mineOperate       #  10,000 colonist operate n mines

        self.factoryCost = raceData.factoryCost      # a factory cost n resources to build
        self.factoryGermCost = raceData.factoryGermCost # True = cost 1kt less of Germanium to build
        self.mineCost = raceData.mineCost         # a mine costs n resources to build



        # Research costs = (75% extra, standard amount, 50% less)
        self.techCostEner = raceData.techCostEner 
        self.techCostWeap = raceData.techCostWeap
        self.techCostProp = raceData.techCostProp
        self.techCostCon = raceData.techCostCon 
        self.techCostElec = raceData.techCostElec
        self.techCostBio = raceData.techCostBio
        
        self.techJumpStart = raceData.techJumpStart # True = All 'Costs 75% extra' fields start at Tech 4


        #self.homeUniverse = None
        #self.race = raceData #RaceData()
        self.colonies = {}  # colony objects
        self.tech = set_base_tech(self.PRT, self.LRT)  # tech object
        self.shipDesign = {} # ship design objects
        self.battleOrders = {} 
        self.production = {} 
        self.turnOrders = {}
        self.diplomacy = {} # diplomacy object?
        self.intel = {} 


    def colonyMining(self):
        pass

    def colonyResources(self):
        pass

    def colonizePlanet(self, planet, pop, fleetMinerals = (25,20,30)):
        '''
        input:  planet = planet object; 
                pop = colonists - typically cargo of colony ship
                fleetMinerals = colony fleet object that has been salvaged

        '''
        newColony = Colony(self.raceData, planet, pop)
        planet.updateSurfaceMinerals(fleetMinerals)

        newColony.planetValue = self.planetValue(planet)
        newColony.growthRate = self.growthRate

        planet.owner = self.raceName

        self.colonies[planet.ID] = newColony
        

    def updateColonyValues(self):
        ''' updateColonyValues called from OrderOfEvents 
        to update colony values before population growth

        uses planetValue()

        '''
        for each in self.colonies:              # for every key in dictionary
            colony = self.colonies[each]        # assign value(colony object)

            value = self.planetValue(colony.planet)

            colony.planetValue = value


    def planetValue(self, planet):
        '''Calculates planet value for player based on Race Data. 

        >used for each colony before OrderOfEvents.population (growth)
        >>> called from Player.updateColonyValues()

        >used when calculating intel on planets


        input:  self.hab values 
                planet hab values

        output: planet value for player (used for colony and planet assessments)

        from m.a@stars
        http://starsautohost.org/sahforum2/index.php?t=msg&th=2299&rid=625&S=ee625fe2bec617564d7c694e9c5379c5&pl_view=&start=0#msg_19643
        http://starsautohost.org/sahforum2/index.php?t=msg&th=2271&start=0&rid=0

        @ju -> check "calculateHabValues2" 

        Origional code written by m.a@stars, just converted to python
        #define BYTE char
        #define WORD short

        #define IMMUNE(a) ((a)==-1)
        
        //simplified for this. Initialized somewhere else
        struct playerDataStruct 
        {
            BYTE lowerHab[3];	 // from 0 to 100 "clicks", -1 for immunity
            BYTE upperHab[3];
        } player;

        //in: an array of 3 bytes from 0 to 100
        //out: a signed integer between -45 and 100
        //hey, it was the Jeffs idea! Smile
        signed long planetValueCalc(BYTE* planetHabData)
        {
            signed long planetValuePoints=0,redValue=0,ideality=10000;	//in fact, they are never < 0
            WORD planetHab,habUpper,habLower,habCenter;
            WORD Excentr,habRadius,margin,Negativ,dist2Center;
        
            for (WORD i=0; i<3; i++) {
                habUpper = player.upperHab[i];
                if (IMMUNE(habUpper)) {			//perfect hab
                    planetValuePoints += 10000;
                }
                else {	//the messy part
                    habLower  = player.lowerHab[i];
                    habCenter = (habUpper+habLower)/2;	//no need to precalc
                    planetHab = planetHabData[i];
        
                    /*
                    note: this version makes the basic assumption that habitability is
                    symmetrical around the center, that is, the ideal center is located
                    in the middle of the lower and upper boundaries, and both halves
                    have the same value. The original algorithm seems able to cope with
                    weirder definitions, i.e: bottom is 20, top is 80, center is 65,
                    and hab value stretches proportionally to the different length of
                    both "halves"...
                    */
                    
                    dist2Center = abs(planetHab-habCenter);
                    habRadius = habCenter-habLower;
        
                    if (dist2Center<=habRadius) {		/* green planet */
              	        Excentr = 100*dist2Center/habRadius;	//note: implicit conversion to integer
            	        Excentr = 100 - Excentr;		//kind of reverse excentricity
            	        planetValuePoints += Excentr*Excentr;
                  	margin = dist2Center*2 - habRadius;
            	        if (margin>0) {		//hab in the "external quarters". dist2Center > 0.5*habRadius
                            ideality *= (double)(3/2 - dist2Center/habRadius);	//decrease ideality up to ~50%
            	            /*
                            ideality *= habRadius*2 - margin;	//better suited for integer math
                            ideality /= habRadius*2;
            	            */
            	        }
                    } else {					/* red planet */
            	        Negativ = dist2Center-habRadius;
            	        if (Negativ>15) Negativ=15;
            	            redValue += Negativ;
                    }
                }
            }
        
        if (redValue!=0) return -redValue;
        planetValuePoints = sqrt((double)planetValuePoints/3)+0.9;	//rounding a la Jeffs
        planetValuePoints = planetValuePoints * ideality/10000;	//note: implicit conversion to integer
        
        return planetValuePoints;		//Thanks ConstB for starting this
        '''
        gc = self.habGravityCenter 
        gr = self.habGravRange 
        
        tc = self.habTempCenter 
        gr = self.habTempRange 

        rc = self.habRadCenter 
        rr = self.habRadRange 

        # playerUpperHab = [gc + gr / 2.,tc + tr / 2. , rc + rr / 2.]
        # playerLowerHab = [gc - gr / 2.,tc - tr / 2. , rc - rr / 2.]
        # planetValuePoints=0,redValue=0,ideality=10000;	//in fact, they are never < 0
        #WORD planetHab,habUpper,habLower,habCenter;
        #WORD Excentr,habRadius,margin,Negativ,dist2Center;        
        for i in range(3):
            pass
            #nevermind, setup to use clicks instead of actual values for hab and -1 for immune, 
            #not sure howto proceed
        #return 10.

        planetValue = 1.0

        return planetValue
            



class RaceTraits(object):
    ''' Most likely RaceTraits will be removed and RaceData will take its place
    '''

    def __init__(self):
        #self.planetMaxPopulation = 1000000  
        pass


class RaceData(object):
    """
    Contains data from RaceWizard.

    possible use this to hold all PRT and LRT values. 
    """
    def __init__(self, raceName):
        self.raceName = raceName
        self.raceNamePlural = raceName
        self.raceIcon = None
        self.LeftOverRWPoints = None

        self.PRT = 'SS'
        self.LRT = []

        self.growthRate = .14
        self.popEfficiency = 1000  # 1 resource per 1000 colonists
        
        '''
        #Environment
        >> Consists of centerpoint & range

        |------<==========x==========>----------------------|

        >> the range value captures only the positive side of the total 
        habitat values 

        immune =  value for centerpoint

        '''
        self.habGravityCenter = 1  # (centerpoint, Click width)?  
        self.habGravRange = 15.0  # pos range from Center. Total range doubled  
        
        self.habTempCenter = 70
        self.habTempRange = 25.0

        self.habRadCenter = 50
        self.habRadRange = 15.0


        self.factoryProduce = 10    # 10 factories produce n resources a year
        self.factoryCost = 10       # a factory cost n resources to build
        self.factoryOperate = 10    # 10,000 colonist operate n factories       
        self.factoryGermCost = False # True = cost 1kt less of Germanium to build

        self.mineProduce = 10       # 10 mines produce n kt of each mineral a year
        self.mineCost = 10          # a mine costs n resources to build
        self.mineOperate = 10       #  10,000 colonist operate n mines
        
        # Research costs = (75% extra, standard amount, 50% less)
        self.techCostEner = 1 
        self.techCostWeap = 1 
        self.techCostProp = 1 
        self.techCostCon = 1 
        self.techCostElec = 1 
        self.techCostBio = 1 
        
        self.techJumpStart = False # True = All 'Costs 75% extra' fields start at Tech 4








